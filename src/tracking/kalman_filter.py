#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
卡尔曼滤波器模块
用于目标运动状态估计和预测
"""

import numpy as np
from typing import Tuple


class 卡尔曼滤波器:
    """
    用于目标跟踪的卡尔曼滤波器
    
    状态向量: [x, y, a, h, vx, vy, va, vh]
    其中 (x, y) 是中心坐标, a 是宽高比, h 是高度
    """
    
    def __init__(self):
        """初始化卡尔曼滤波器"""
        # 状态维度和观测维度
        self.状态维度 = 8
        self.观测维度 = 4
        
        # 状态转移矩阵 F
        self.F = np.eye(self.状态维度)
        for i in range(4):
            self.F[i, i + 4] = 1.0  # 位置更新依赖速度
        
        # 观测矩阵 H
        self.H = np.eye(self.观测维度, self.状态维度)
        
        # 过程噪声权重
        self._位置标准差权重 = 1.0 / 20
        self._速度标准差权重 = 1.0 / 160
    
    def 初始化(self, 观测: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        从初始观测初始化状态
        
        参数:
            观测: [x, y, a, h] 边界框参数
        
        返回:
            初始状态均值, 初始状态协方差
        """
        均值 = np.zeros(self.状态维度)
        均值[:4] = 观测
        
        # 初始协方差
        标准差 = [
            2 * self._位置标准差权重 * 观测[3],    # x
            2 * self._位置标准差权重 * 观测[3],    # y
            1e-2,                                   # a
            2 * self._位置标准差权重 * 观测[3],    # h
            10 * self._速度标准差权重 * 观测[3],   # vx
            10 * self._速度标准差权重 * 观测[3],   # vy
            1e-5,                                   # va
            10 * self._速度标准差权重 * 观测[3],   # vh
        ]
        
        协方差 = np.diag(np.square(标准差))
        
        return 均值, 协方差
    
    def 预测(self, 均值: np.ndarray, 协方差: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        执行预测步骤
        
        参数:
            均值: 当前状态均值
            协方差: 当前状态协方差
        
        返回:
            预测状态均值, 预测状态协方差
        """
        # 过程噪声
        标准差位置 = [
            self._位置标准差权重 * 均值[3],
            self._位置标准差权重 * 均值[3],
            1e-2,
            self._位置标准差权重 * 均值[3],
        ]
        
        标准差速度 = [
            self._速度标准差权重 * 均值[3],
            self._速度标准差权重 * 均值[3],
            1e-5,
            self._速度标准差权重 * 均值[3],
        ]
        
        过程噪声 = np.diag(np.square(标准差位置 + 标准差速度))
        
        # 预测
        预测均值 = self.F @ 均值
        预测协方差 = self.F @ 协方差 @ self.F.T + 过程噪声
        
        return 预测均值, 预测协方差
    
    def 更新(
        self, 
        均值: np.ndarray, 
        协方差: np.ndarray, 
        观测: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        执行更新步骤
        
        参数:
            均值: 预测状态均值
            协方差: 预测状态协方差
            观测: 新观测 [x, y, a, h]
        
        返回:
            更新后状态均值, 更新后状态协方差
        """
        # 观测噪声
        标准差 = [
            self._位置标准差权重 * 均值[3],
            self._位置标准差权重 * 均值[3],
            1e-1,
            self._位置标准差权重 * 均值[3],
        ]
        观测噪声 = np.diag(np.square(标准差))
        
        # 投影到观测空间
        投影均值 = self.H @ 均值
        投影协方差 = self.H @ 协方差 @ self.H.T + 观测噪声
        
        # 卡尔曼增益
        增益 = 协方差 @ self.H.T @ np.linalg.inv(投影协方差)
        
        # 更新
        创新 = 观测 - 投影均值
        新均值 = 均值 + 增益 @ 创新
        新协方差 = (np.eye(self.状态维度) - 增益 @ self.H) @ 协方差
        
        return 新均值, 新协方差
    
    def 计算门控距离(
        self, 
        均值: np.ndarray, 
        协方差: np.ndarray, 
        观测: np.ndarray
    ) -> float:
        """
        计算马氏距离（门控距离）
        
        参数:
            均值: 状态均值
            协方差: 状态协方差
            观测: 观测值
        
        返回:
            马氏距离
        """
        # 投影到观测空间
        投影均值 = self.H @ 均值
        
        # 计算观测协方差
        标准差 = [
            self._位置标准差权重 * 均值[3],
            self._位置标准差权重 * 均值[3],
            1e-1,
            self._位置标准差权重 * 均值[3],
        ]
        观测噪声 = np.diag(np.square(标准差))
        投影协方差 = self.H @ 协方差 @ self.H.T + 观测噪声
        
        # 计算马氏距离
        差值 = 观测 - 投影均值
        距离 = 差值 @ np.linalg.inv(投影协方差) @ 差值
        
        return 距离


def xyxy转xywh(边界框: np.ndarray) -> np.ndarray:
    """
    将 [x1, y1, x2, y2] 转换为 [cx, cy, w, h]
    
    参数:
        边界框: [N, 4] 或 [4] 边界框数组
    
    返回:
        转换后的边界框
    """
    结果 = np.empty_like(边界框)
    
    if 边界框.ndim == 1:
        结果[0] = (边界框[0] + 边界框[2]) / 2  # cx
        结果[1] = (边界框[1] + 边界框[3]) / 2  # cy
        结果[2] = 边界框[2] - 边界框[0]         # w
        结果[3] = 边界框[3] - 边界框[1]         # h
    else:
        结果[:, 0] = (边界框[:, 0] + 边界框[:, 2]) / 2
        结果[:, 1] = (边界框[:, 1] + 边界框[:, 3]) / 2
        结果[:, 2] = 边界框[:, 2] - 边界框[:, 0]
        结果[:, 3] = 边界框[:, 3] - 边界框[:, 1]
    
    return 结果


def xywh转xyxy(边界框: np.ndarray) -> np.ndarray:
    """
    将 [cx, cy, w, h] 转换为 [x1, y1, x2, y2]
    
    参数:
        边界框: [N, 4] 或 [4] 边界框数组
    
    返回:
        转换后的边界框
    """
    结果 = np.empty_like(边界框)
    
    if 边界框.ndim == 1:
        结果[0] = 边界框[0] - 边界框[2] / 2  # x1
        结果[1] = 边界框[1] - 边界框[3] / 2  # y1
        结果[2] = 边界框[0] + 边界框[2] / 2  # x2
        结果[3] = 边界框[1] + 边界框[3] / 2  # y2
    else:
        结果[:, 0] = 边界框[:, 0] - 边界框[:, 2] / 2
        结果[:, 1] = 边界框[:, 1] - 边界框[:, 3] / 2
        结果[:, 2] = 边界框[:, 0] + 边界框[:, 2] / 2
        结果[:, 3] = 边界框[:, 1] + 边界框[:, 3] / 2
    
    return 结果


def xyxy转xyah(边界框: np.ndarray) -> np.ndarray:
    """
    将 [x1, y1, x2, y2] 转换为 [cx, cy, aspect_ratio, height]
    
    参数:
        边界框: [N, 4] 或 [4] 边界框数组
    
    返回:
        转换后的边界框
    """
    结果 = np.empty_like(边界框)
    
    if 边界框.ndim == 1:
        w = 边界框[2] - 边界框[0]
        h = 边界框[3] - 边界框[1]
        结果[0] = (边界框[0] + 边界框[2]) / 2  # cx
        结果[1] = (边界框[1] + 边界框[3]) / 2  # cy
        结果[2] = w / h if h > 0 else 0          # aspect_ratio
        结果[3] = h                              # height
    else:
        w = 边界框[:, 2] - 边界框[:, 0]
        h = 边界框[:, 3] - 边界框[:, 1]
        结果[:, 0] = (边界框[:, 0] + 边界框[:, 2]) / 2
        结果[:, 1] = (边界框[:, 1] + 边界框[:, 3]) / 2
        结果[:, 2] = np.where(h > 0, w / h, 0)
        结果[:, 3] = h
    
    return 结果


def xyah转xyxy(边界框: np.ndarray) -> np.ndarray:
    """
    将 [cx, cy, aspect_ratio, height] 转换为 [x1, y1, x2, y2]
    
    参数:
        边界框: [N, 4] 或 [4] 边界框数组
    
    返回:
        转换后的边界框
    """
    结果 = np.empty_like(边界框)
    
    if 边界框.ndim == 1:
        w = 边界框[2] * 边界框[3]  # aspect_ratio * height = width
        h = 边界框[3]
        结果[0] = 边界框[0] - w / 2  # x1
        结果[1] = 边界框[1] - h / 2  # y1
        结果[2] = 边界框[0] + w / 2  # x2
        结果[3] = 边界框[1] + h / 2  # y2
    else:
        w = 边界框[:, 2] * 边界框[:, 3]
        h = 边界框[:, 3]
        结果[:, 0] = 边界框[:, 0] - w / 2
        结果[:, 1] = 边界框[:, 1] - h / 2
        结果[:, 2] = 边界框[:, 0] + w / 2
        结果[:, 3] = 边界框[:, 1] + h / 2
    
    return 结果
